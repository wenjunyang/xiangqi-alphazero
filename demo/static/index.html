<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ä¸­å›½è±¡æ£‹AIæ¼”ç¤º</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
  background: #1a1a2e;
  color: #e0e0e0;
  min-height: 100vh;
}

/* é¡¶éƒ¨æ ‡é¢˜ */
.header {
  background: linear-gradient(135deg, #16213e, #0f3460);
  padding: 12px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #2a2a4a;
}
.header h1 {
  font-size: 20px;
  color: #e94560;
  font-weight: 700;
}
.header .subtitle {
  font-size: 12px;
  color: #888;
  margin-top: 2px;
}
.header .status {
  font-size: 13px;
  color: #aaa;
}
.status .dot {
  display: inline-block;
  width: 8px; height: 8px;
  border-radius: 50%;
  margin-right: 6px;
  background: #555;
}
.status .dot.loaded { background: #4caf50; }
.status .dot.thinking { background: #ff9800; animation: pulse 1s infinite; }
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

/* ä¸»å¸ƒå±€ */
.main {
  display: flex;
  gap: 20px;
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
  align-items: flex-start;
}

/* å·¦ä¾§ï¼šæ£‹ç›˜ */
.board-section {
  flex-shrink: 0;
}
#board-canvas {
  cursor: pointer;
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
}
.turn-info {
  text-align: center;
  margin-top: 10px;
  font-size: 15px;
  padding: 8px;
  border-radius: 6px;
  background: #16213e;
}
.turn-info .red { color: #e94560; font-weight: 600; }
.turn-info .black { color: #ccc; font-weight: 600; }
.turn-info .thinking { color: #ff9800; }
.game-result {
  text-align: center;
  margin-top: 8px;
  font-size: 18px;
  font-weight: 700;
  padding: 10px;
  border-radius: 6px;
  display: none;
}
.game-result.show { display: block; }
.game-result.red-win { background: #e94560; color: #fff; }
.game-result.black-win { background: #333; color: #fff; }
.game-result.draw { background: #666; color: #fff; }

/* å³ä¾§é¢æ¿ */
.panel-section {
  flex: 1;
  min-width: 320px;
  max-width: 420px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.card {
  background: #16213e;
  border: 1px solid #2a2a4a;
  border-radius: 10px;
  overflow: hidden;
}
.card-header {
  padding: 12px 16px;
  font-size: 14px;
  font-weight: 600;
  color: #e94560;
  border-bottom: 1px solid #2a2a4a;
  display: flex;
  align-items: center;
  gap: 8px;
}
.card-body {
  padding: 16px;
}

/* æ§åˆ¶é¢æ¿ */
.control-row {
  display: flex;
  gap: 10px;
  margin-bottom: 12px;
  align-items: center;
}
.control-row label {
  font-size: 13px;
  color: #aaa;
  min-width: 80px;
  flex-shrink: 0;
}
.control-row select,
.control-row input[type="number"] {
  flex: 1;
  padding: 8px 10px;
  border-radius: 6px;
  border: 1px solid #2a2a4a;
  background: #0f3460;
  color: #e0e0e0;
  font-size: 13px;
  outline: none;
}
.control-row select:focus,
.control-row input:focus {
  border-color: #e94560;
}

.btn-group {
  display: flex;
  gap: 8px;
}
.btn {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}
.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.btn-primary {
  background: #e94560;
  color: #fff;
}
.btn-primary:hover:not(:disabled) { background: #d63851; }
.btn-secondary {
  background: #2a2a4a;
  color: #ccc;
}
.btn-secondary:hover:not(:disabled) { background: #3a3a5a; }

.side-select {
  display: flex;
  gap: 6px;
}
.side-btn {
  flex: 1;
  padding: 8px;
  border: 2px solid #2a2a4a;
  border-radius: 6px;
  background: transparent;
  color: #aaa;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}
.side-btn.active-red {
  border-color: #e94560;
  color: #e94560;
  background: rgba(233,69,96,0.1);
}
.side-btn.active-black {
  border-color: #888;
  color: #fff;
  background: rgba(255,255,255,0.1);
}

/* AIåˆ†æé¢æ¿ */
.value-bar-container {
  margin-bottom: 16px;
}
.value-label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #888;
  margin-bottom: 4px;
}
.value-bar {
  height: 28px;
  background: #333;
  border-radius: 14px;
  overflow: hidden;
  position: relative;
}
.value-bar-fill {
  height: 100%;
  transition: width 0.5s ease;
  border-radius: 14px;
}
.value-bar-fill.positive {
  background: linear-gradient(90deg, #e94560, #ff6b6b);
}
.value-bar-fill.negative {
  background: linear-gradient(90deg, #555, #888);
}
.value-score {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 13px;
  font-weight: 700;
  color: #fff;
  text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

.move-list {
  list-style: none;
}
.move-item {
  display: flex;
  align-items: center;
  padding: 6px 8px;
  margin-bottom: 4px;
  border-radius: 6px;
  font-size: 13px;
  transition: background 0.2s;
}
.move-item:hover {
  background: rgba(255,255,255,0.05);
}
.move-item.selected {
  background: rgba(233,69,96,0.15);
  border-left: 3px solid #e94560;
}
.move-item.illegal {
  opacity: 0.4;
}
.move-rank {
  width: 22px;
  font-size: 11px;
  color: #666;
  flex-shrink: 0;
}
.move-label {
  flex: 1;
  font-family: 'Courier New', monospace;
  font-size: 13px;
}
.move-prob {
  width: 50px;
  text-align: right;
  font-weight: 600;
  font-size: 13px;
  margin-right: 8px;
}
.move-bar {
  width: 80px;
  height: 6px;
  background: #2a2a4a;
  border-radius: 3px;
  overflow: hidden;
  flex-shrink: 0;
}
.move-bar-fill {
  height: 100%;
  background: #e94560;
  border-radius: 3px;
  transition: width 0.3s;
}
.move-tag {
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: 6px;
  flex-shrink: 0;
}
.move-tag.selected-tag { background: #e94560; color: #fff; }
.move-tag.legal-tag { background: #2a5a2a; color: #6f6; }
.move-tag.illegal-tag { background: #5a2a2a; color: #f66; }

/* èµ°æ£‹å†å² */
.history-list {
  max-height: 200px;
  overflow-y: auto;
  font-size: 12px;
  font-family: 'Courier New', monospace;
}
.history-item {
  padding: 3px 8px;
  border-bottom: 1px solid #1a1a2e;
}
.history-item:nth-child(odd) { background: rgba(255,255,255,0.02); }

/* æ— æ¨¡å‹æç¤º */
.no-model-hint {
  text-align: center;
  padding: 20px;
  color: #888;
  font-size: 13px;
}
.no-model-hint .icon { font-size: 40px; margin-bottom: 10px; }

/* åŠ è½½ä¸­ */
.loading-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
  display: none;
}
.loading-overlay.show { display: flex; }
.loading-spinner {
  background: #16213e;
  padding: 30px 40px;
  border-radius: 12px;
  text-align: center;
}
.loading-spinner .spinner {
  width: 40px; height: 40px;
  border: 4px solid #2a2a4a;
  border-top-color: #e94560;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin: 0 auto 12px;
}
@keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<div class="header">
  <div>
    <h1>ä¸­å›½è±¡æ£‹AI</h1>
    <div class="subtitle">AlphaZero å¼ºåŒ–å­¦ä¹  Â· MCTS æœç´¢</div>
  </div>
  <div class="status" id="status">
    <span class="dot" id="status-dot"></span>
    <span id="status-text">æœªåŠ è½½æ¨¡å‹</span>
  </div>
</div>

<div class="main">
  <!-- å·¦ä¾§ï¼šæ£‹ç›˜ -->
  <div class="board-section">
    <canvas id="board-canvas" width="540" height="600"></canvas>
    <div class="turn-info" id="turn-info">è¯·å…ˆåŠ è½½æ¨¡å‹å¹¶å¼€å§‹æ–°æ¸¸æˆ</div>
    <div class="game-result" id="game-result"></div>
  </div>

  <!-- å³ä¾§é¢æ¿ -->
  <div class="panel-section">
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="card">
      <div class="card-header">âš™ å¯¹å±€è®¾ç½®</div>
      <div class="card-body">
        <div class="control-row">
          <label>AIæ¨¡å‹</label>
          <select id="model-select"><option value="">åŠ è½½ä¸­...</option></select>
        </div>
        <div class="control-row">
          <label>MCTSæ¬¡æ•°</label>
          <input type="number" id="simulations" value="500" min="10" max="10000" step="10">
        </div>
        <div class="control-row">
          <label>æ‰§å­æ–¹</label>
          <div class="side-select">
            <button class="side-btn active-red" id="side-red" onclick="selectSide('red')">æ‰§çº¢å…ˆè¡Œ</button>
            <button class="side-btn" id="side-black" onclick="selectSide('black')">æ‰§é»‘åè¡Œ</button>
          </div>
        </div>
        <div class="btn-group" style="margin-top: 4px;">
          <button class="btn btn-primary" id="btn-new-game" onclick="newGame()">æ–°å±€</button>
          <button class="btn btn-secondary" id="btn-load-model" onclick="loadModel()">åŠ è½½æ¨¡å‹</button>
        </div>
      </div>
    </div>

    <!-- AIåˆ†æé¢æ¿ -->
    <div class="card">
      <div class="card-header">ğŸ§  AIåˆ†æ</div>
      <div class="card-body" id="analysis-panel">
        <div class="no-model-hint" id="no-analysis">
          <div class="icon">ğŸ¯</div>
          AIèµ°æ£‹åå°†æ˜¾ç¤ºåˆ†æç»“æœ
        </div>
        <div id="analysis-content" style="display:none;">
          <div class="value-bar-container">
            <div class="value-label">
              <span>é»‘æ–¹ä¼˜åŠ¿</span>
              <span>çº¢æ–¹ä¼˜åŠ¿</span>
            </div>
            <div class="value-bar">
              <div class="value-bar-fill positive" id="value-bar-fill"></div>
              <div class="value-score" id="value-score-text">0.000</div>
            </div>
          </div>
          <div style="font-size:12px; color:#888; margin-bottom:8px;">
            Topèµ°æ³• (MCTSæœç´¢æ¦‚ç‡)
          </div>
          <ul class="move-list" id="move-list"></ul>
        </div>
      </div>
    </div>

    <!-- èµ°æ£‹å†å² -->
    <div class="card">
      <div class="card-header">ğŸ“œ èµ°æ£‹è®°å½•</div>
      <div class="card-body">
        <div class="history-list" id="history-list">
          <div style="color:#666; font-size:13px; text-align:center; padding:10px;">æš‚æ— è®°å½•</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- åŠ è½½é®ç½© -->
<div class="loading-overlay" id="loading">
  <div class="loading-spinner">
    <div class="spinner"></div>
    <div id="loading-text">åŠ è½½ä¸­...</div>
  </div>
</div>

<script>
// ============================================================
// å¸¸é‡
// ============================================================
const ROWS = 10, COLS = 9;
const CELL_SIZE = 60;
const PADDING = 30;
const BOARD_W = CELL_SIZE * (COLS - 1) + PADDING * 2;
const BOARD_H = CELL_SIZE * (ROWS - 1) + PADDING * 2;

const PIECE_CHARS = {
  1: 'å¸…', 2: 'ä»•', 3: 'ç›¸', 4: 'é¦¬', 5: 'è»Š', 6: 'ç‚®', 7: 'å…µ',
  '-1': 'å°†', '-2': 'å£«', '-3': 'è±¡', '-4': 'é¦¬', '-5': 'è»Š', '-6': 'ç‚®', '-7': 'å’'
};

// ============================================================
// çŠ¶æ€
// ============================================================
let board = null;
let currentPlayer = 1;
let humanSide = 1;
let selectedPiece = null;
let validMoves = [];
let lastAiMove = null;
let lastHumanMove = null;
let gameOver = false;
let isThinking = false;
let moveHistory = [];
let flipped = true; // æ˜¯å¦ç¿»è½¬æ£‹ç›˜ï¼ˆæ‰§çº¢æ—¶ç¿»è½¬ï¼Œè®©çº¢æ–¹åœ¨ä¸‹æ–¹ï¼‰

const canvas = document.getElementById('board-canvas');
const ctx = canvas.getContext('2d');
canvas.width = BOARD_W;
canvas.height = BOARD_H;

// ============================================================
// ç»˜åˆ¶æ£‹ç›˜
// ============================================================
function drawBoard() {
  const W = BOARD_W, H = BOARD_H;
  const P = PADDING, S = CELL_SIZE;

  // èƒŒæ™¯
  ctx.fillStyle = '#d4a76a';
  ctx.fillRect(0, 0, W, H);

  // æœ¨çº¹æ•ˆæœ
  ctx.fillStyle = 'rgba(139, 90, 43, 0.08)';
  for (let i = 0; i < H; i += 3) {
    ctx.fillRect(0, i, W, 1);
  }

  ctx.strokeStyle = '#5a3a1a';
  ctx.lineWidth = 1;

  // æ¨ªçº¿
  for (let r = 0; r < ROWS; r++) {
    ctx.beginPath();
    ctx.moveTo(P, P + r * S);
    ctx.lineTo(P + 8 * S, P + r * S);
    ctx.stroke();
  }

  // ç«–çº¿
  for (let c = 0; c < COLS; c++) {
    // ä¸ŠåŠéƒ¨åˆ†
    ctx.beginPath();
    ctx.moveTo(P + c * S, P);
    ctx.lineTo(P + c * S, P + 4 * S);
    ctx.stroke();
    // ä¸‹åŠéƒ¨åˆ†
    ctx.beginPath();
    ctx.moveTo(P + c * S, P + 5 * S);
    ctx.lineTo(P + c * S, P + 9 * S);
    ctx.stroke();
  }
  // å·¦å³è¾¹çº¿è´¯ç©¿
  ctx.beginPath();
  ctx.moveTo(P, P); ctx.lineTo(P, P + 9 * S);
  ctx.moveTo(P + 8 * S, P); ctx.lineTo(P + 8 * S, P + 9 * S);
  ctx.stroke();

  // ä¹å®«æ ¼æ–œçº¿
  ctx.beginPath();
  // ä¸Šæ–¹ä¹å®«ï¼ˆé»‘æ–¹ï¼‰
  let topPalaceRow = flipped ? 0 : 7;
  let botPalaceRow = flipped ? 7 : 0;
  ctx.moveTo(P + 3 * S, P + topPalaceRow * S);
  ctx.lineTo(P + 5 * S, P + (topPalaceRow + 2) * S);
  ctx.moveTo(P + 5 * S, P + topPalaceRow * S);
  ctx.lineTo(P + 3 * S, P + (topPalaceRow + 2) * S);
  // ä¸‹æ–¹ä¹å®«ï¼ˆçº¢æ–¹ï¼‰
  ctx.moveTo(P + 3 * S, P + botPalaceRow * S);
  ctx.lineTo(P + 5 * S, P + (botPalaceRow + 2) * S);
  ctx.moveTo(P + 5 * S, P + botPalaceRow * S);
  ctx.lineTo(P + 3 * S, P + (botPalaceRow + 2) * S);
  ctx.stroke();

  // æ¥šæ²³æ±‰ç•Œ
  ctx.fillStyle = '#5a3a1a';
  ctx.font = 'bold 22px serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const riverY = P + 4.5 * S;
  if (flipped) {
    ctx.fillText('æ¼¢ã€€ç•Œ', P + 2 * S, riverY);
    ctx.fillText('æ¥šã€€æ²³', P + 6 * S, riverY);
  } else {
    ctx.fillText('æ¥šã€€æ²³', P + 2 * S, riverY);
    ctx.fillText('æ¼¢ã€€ç•Œ', P + 6 * S, riverY);
  }

  // å¤–è¾¹æ¡†
  ctx.strokeStyle = '#5a3a1a';
  ctx.lineWidth = 3;
  ctx.strokeRect(P - 8, P - 8, 8 * S + 16, 9 * S + 16);
}

function boardToScreen(row, col) {
  const displayRow = flipped ? (9 - row) : row;
  const displayCol = flipped ? (8 - col) : col;
  return {
    x: PADDING + displayCol * CELL_SIZE,
    y: PADDING + displayRow * CELL_SIZE,
  };
}

function screenToBoard(sx, sy) {
  let displayCol = Math.round((sx - PADDING) / CELL_SIZE);
  let displayRow = Math.round((sy - PADDING) / CELL_SIZE);
  if (displayRow < 0 || displayRow > 9 || displayCol < 0 || displayCol > 8) return null;
  const row = flipped ? (9 - displayRow) : displayRow;
  const col = flipped ? (8 - displayCol) : displayCol;
  return { row, col };
}

function drawPiece(row, col, piece) {
  if (piece === 0) return;
  const { x, y } = boardToScreen(row, col);
  const r = 26;

  // æ£‹å­åº•è‰²
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  const isRed = piece > 0;
  ctx.fillStyle = isRed ? '#f5e6d0' : '#f5e6d0';
  ctx.fill();
  ctx.strokeStyle = isRed ? '#8b0000' : '#1a1a1a';
  ctx.lineWidth = 2;
  ctx.stroke();

  // å†…åœˆ
  ctx.beginPath();
  ctx.arc(x, y, r - 4, 0, Math.PI * 2);
  ctx.strokeStyle = isRed ? '#c0392b' : '#555';
  ctx.lineWidth = 1;
  ctx.stroke();

  // æ–‡å­—
  ctx.fillStyle = isRed ? '#c0392b' : '#1a1a1a';
  ctx.font = 'bold 22px "KaiTi", "STKaiti", "SimSun", serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(PIECE_CHARS[piece] || '?', x, y + 1);
}

function drawHighlight(row, col, color, type) {
  const { x, y } = boardToScreen(row, col);
  if (type === 'selected') {
    ctx.beginPath();
    ctx.arc(x, y, 28, 0, Math.PI * 2);
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.stroke();
  } else if (type === 'valid') {
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  } else if (type === 'last-move') {
    ctx.beginPath();
    ctx.arc(x, y, 28, 0, Math.PI * 2);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

function render() {
  drawBoard();
  if (!board) return;

  // ç»˜åˆ¶ä¸Šä¸€æ­¥èµ°æ³•é«˜äº®
  if (lastAiMove) {
    drawHighlight(lastAiMove.from[0], lastAiMove.from[1], 'rgba(255,152,0,0.5)', 'last-move');
    drawHighlight(lastAiMove.to[0], lastAiMove.to[1], 'rgba(255,152,0,0.5)', 'last-move');
  }
  if (lastHumanMove) {
    drawHighlight(lastHumanMove.from[0], lastHumanMove.from[1], 'rgba(76,175,80,0.4)', 'last-move');
    drawHighlight(lastHumanMove.to[0], lastHumanMove.to[1], 'rgba(76,175,80,0.4)', 'last-move');
  }

  // ç»˜åˆ¶é€‰ä¸­æ£‹å­å’Œåˆæ³•èµ°æ³•
  if (selectedPiece) {
    drawHighlight(selectedPiece.row, selectedPiece.col, '#4caf50', 'selected');
    for (const [tr, tc] of validMoves) {
      const target = board[tr][tc];
      if (target !== 0) {
        drawHighlight(tr, tc, 'rgba(244,67,54,0.6)', 'selected');
      } else {
        drawHighlight(tr, tc, 'rgba(76,175,80,0.5)', 'valid');
      }
    }
  }

  // ç»˜åˆ¶æ£‹å­
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      drawPiece(r, c, board[r][c]);
    }
  }
}

// ============================================================
// äº¤äº’é€»è¾‘
// ============================================================
canvas.addEventListener('click', async (e) => {
  if (!board || gameOver || isThinking) return;
  if (currentPlayer !== humanSide) return;

  const rect = canvas.getBoundingClientRect();
  const sx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const sy = (e.clientY - rect.top) * (canvas.height / rect.height);
  const pos = screenToBoard(sx, sy);
  if (!pos) return;

  const { row, col } = pos;
  const piece = board[row][col];

  // å¦‚æœç‚¹å‡»äº†è‡ªå·±çš„æ£‹å­ â†’ é€‰ä¸­
  if ((humanSide === 1 && piece > 0) || (humanSide === -1 && piece < 0)) {
    selectedPiece = { row, col };
    // è¯·æ±‚åˆæ³•èµ°æ³•
    const resp = await fetch('/api/get_legal_moves', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ row, col }),
    });
    const data = await resp.json();
    validMoves = data.moves || [];
    render();
    return;
  }

  // å¦‚æœå·²é€‰ä¸­æ£‹å­ä¸”ç‚¹å‡»äº†åˆæ³•ç›®æ ‡ â†’ èµ°æ£‹
  if (selectedPiece) {
    const isValid = validMoves.some(([tr, tc]) => tr === row && tc === col);
    if (isValid) {
      await doHumanMove(selectedPiece.row, selectedPiece.col, row, col);
    } else {
      // å–æ¶ˆé€‰æ‹©
      selectedPiece = null;
      validMoves = [];
      render();
    }
  }
});

async function doHumanMove(fr, fc, tr, tc) {
  selectedPiece = null;
  validMoves = [];
  isThinking = true;
  updateTurnInfo();

  try {
    const resp = await fetch('/api/human_move', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ from_row: fr, from_col: fc, to_row: tr, to_col: tc }),
    });
    const data = await resp.json();

    if (data.error) {
      alert(data.error);
      isThinking = false;
      updateTurnInfo();
      return;
    }

    // è®°å½•äººç±»èµ°æ³•
    lastHumanMove = { from: [fr, fc], to: [tr, tc] };
    addHistory(humanSide, `(${fr},${fc})â†’(${tr},${tc})`);

    // æ›´æ–°æ£‹ç›˜
    board = data.board;
    currentPlayer = data.current_player;
    gameOver = data.game_over;

    // AIèµ°æ³•
    if (data.ai_move) {
      lastAiMove = data.ai_move;
      addHistory(-humanSide, data.ai_move.label || `(${data.ai_move.from[0]},${data.ai_move.from[1]})â†’(${data.ai_move.to[0]},${data.ai_move.to[1]})`);
      currentPlayer = data.current_player;
      gameOver = data.game_over;
    }

    // AIåˆ†æ
    if (data.ai_analysis) {
      updateAnalysis(data.ai_analysis);
    }

    // æ¸¸æˆç»“æŸ
    if (data.game_over) {
      showGameResult(data.winner);
    }
  } catch (err) {
    console.error(err);
    alert('è¯·æ±‚å¤±è´¥: ' + err.message);
  }

  isThinking = false;
  render();
  updateTurnInfo();
}

// ============================================================
// UIæ›´æ–°
// ============================================================
function updateTurnInfo() {
  const el = document.getElementById('turn-info');
  if (!board) {
    el.innerHTML = 'è¯·å…ˆåŠ è½½æ¨¡å‹å¹¶å¼€å§‹æ–°æ¸¸æˆ';
    return;
  }
  if (gameOver) {
    el.innerHTML = 'æ¸¸æˆç»“æŸ';
    return;
  }
  if (isThinking) {
    el.innerHTML = '<span class="thinking">ğŸ¤” AIæ€è€ƒä¸­...</span>';
    document.getElementById('status-dot').className = 'dot thinking';
    document.getElementById('status-text').textContent = 'AIæ€è€ƒä¸­...';
    return;
  }
  if (currentPlayer === humanSide) {
    const sideText = humanSide === 1 ? '<span class="red">çº¢æ–¹</span>' : '<span class="black">é»‘æ–¹</span>';
    el.innerHTML = `è½®åˆ°ä½ èµ°æ£‹ (${sideText})`;
  } else {
    el.innerHTML = 'ç­‰å¾…AI...';
  }
  document.getElementById('status-dot').className = 'dot loaded';
  document.getElementById('status-text').textContent = 'å°±ç»ª';
}

function updateAnalysis(analysis) {
  document.getElementById('no-analysis').style.display = 'none';
  document.getElementById('analysis-content').style.display = 'block';

  // Value bar
  const v = analysis.value_score;
  const pct = Math.max(5, Math.min(95, (v + 1) / 2 * 100));
  const fill = document.getElementById('value-bar-fill');
  fill.style.width = pct + '%';
  fill.className = 'value-bar-fill ' + (v >= 0 ? 'positive' : 'negative');
  document.getElementById('value-score-text').textContent = (v >= 0 ? '+' : '') + v.toFixed(3);

  // Top moves
  const list = document.getElementById('move-list');
  list.innerHTML = '';
  for (let i = 0; i < analysis.top_moves.length; i++) {
    const m = analysis.top_moves[i];
    const li = document.createElement('li');
    li.className = 'move-item' + (m.selected ? ' selected' : '') + (!m.legal ? ' illegal' : '');

    let tag = '';
    if (m.selected) tag = '<span class="move-tag selected-tag">é€‰æ‹©</span>';
    else if (m.legal) tag = '<span class="move-tag legal-tag">åˆæ³•</span>';
    else tag = '<span class="move-tag illegal-tag">éæ³•</span>';

    li.innerHTML = `
      <span class="move-rank">${i + 1}</span>
      <span class="move-label">${m.label}</span>
      <span class="move-prob">${(m.prob * 100).toFixed(1)}%</span>
      <div class="move-bar"><div class="move-bar-fill" style="width:${m.prob * 100 / (analysis.top_moves[0]?.prob || 1) * 100}%"></div></div>
      ${tag}
    `;
    list.appendChild(li);
  }
}

function showGameResult(winner) {
  const el = document.getElementById('game-result');
  el.classList.add('show');
  if (winner === 1) {
    el.className = 'game-result show red-win';
    el.textContent = 'çº¢æ–¹èƒœï¼';
  } else if (winner === -1) {
    el.className = 'game-result show black-win';
    el.textContent = 'é»‘æ–¹èƒœï¼';
  } else {
    el.className = 'game-result show draw';
    el.textContent = 'å’Œæ£‹';
  }
}

function addHistory(player, text) {
  const list = document.getElementById('history-list');
  if (moveHistory.length === 0) list.innerHTML = '';
  const n = moveHistory.length + 1;
  const side = player === 1 ? 'çº¢' : 'é»‘';
  const item = document.createElement('div');
  item.className = 'history-item';
  item.textContent = `${n}. [${side}] ${text}`;
  list.appendChild(item);
  list.scrollTop = list.scrollHeight;
  moveHistory.push({ player, text });
}

function selectSide(side) {
  humanSide = side === 'red' ? 1 : -1;
  flipped = (humanSide === 1); // æ‰§çº¢ç¿»è½¬ï¼ˆçº¢æ–¹row=0åœ¨ä¸‹æ–¹ï¼‰ï¼Œæ‰§é»‘ä¸ç¿»è½¬ï¼ˆé»‘æ–¹row=9åœ¨ä¸‹æ–¹ï¼‰
  document.getElementById('side-red').className = 'side-btn' + (side === 'red' ? ' active-red' : '');
  document.getElementById('side-black').className = 'side-btn' + (side === 'black' ? ' active-black' : '');
  render();
}

// ============================================================
// APIè°ƒç”¨
// ============================================================
async function loadModels() {
  try {
    const resp = await fetch('/api/models');
    const data = await resp.json();
    const sel = document.getElementById('model-select');
    sel.innerHTML = '';
    if (data.models.length === 0) {
      sel.innerHTML = '<option value="">æ— å¯ç”¨æ¨¡å‹</option>';
      return;
    }
    for (const m of data.models) {
      const opt = document.createElement('option');
      opt.value = m.name;
      opt.textContent = `${m.name} (${m.size_mb}MB)`;
      if (m.name === data.current) opt.selected = true;
      sel.appendChild(opt);
    }
  } catch (e) {
    console.error('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥:', e);
  }
}

async function loadModel() {
  const modelName = document.getElementById('model-select').value;
  if (!modelName) { alert('è¯·é€‰æ‹©æ¨¡å‹'); return; }

  showLoading('æ­£åœ¨åŠ è½½æ¨¡å‹...');
  try {
    const resp = await fetch('/api/load_model', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model_name: modelName }),
    });
    const data = await resp.json();
    if (data.error) {
      alert('åŠ è½½å¤±è´¥: ' + data.error);
    } else {
      document.getElementById('status-dot').className = 'dot loaded';
      document.getElementById('status-text').textContent = `å·²åŠ è½½: ${data.model_name}`;
    }
  } catch (e) {
    alert('åŠ è½½å¤±è´¥: ' + e.message);
  }
  hideLoading();
}

async function newGame() {
  const sims = parseInt(document.getElementById('simulations').value) || 500;
  const side = humanSide === 1 ? 'red' : 'black';

  showLoading('å¼€å§‹æ–°æ¸¸æˆ...');
  try {
    const resp = await fetch('/api/new_game', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ human_side: side, num_simulations: sims }),
    });
    const data = await resp.json();

    board = data.board;
    currentPlayer = data.current_player;
    humanSide = data.human_side;
    flipped = (humanSide === 1); // æ‰§çº¢ç¿»è½¬ï¼Œæ‰§é»‘ä¸ç¿»è½¬
    gameOver = false;
    selectedPiece = null;
    validMoves = [];
    lastAiMove = null;
    lastHumanMove = null;
    moveHistory = [];

    // æ›´æ–°æ‰§å­æŒ‰é’®
    document.getElementById('side-red').className = 'side-btn' + (humanSide === 1 ? ' active-red' : '');
    document.getElementById('side-black').className = 'side-btn' + (humanSide === -1 ? ' active-black' : '');

    // éšè—æ¸¸æˆç»“æœ
    document.getElementById('game-result').classList.remove('show');
    // é‡ç½®å†å²
    document.getElementById('history-list').innerHTML = '<div style="color:#666; font-size:13px; text-align:center; padding:10px;">æš‚æ— è®°å½•</div>';
    // é‡ç½®åˆ†æ
    document.getElementById('no-analysis').style.display = 'block';
    document.getElementById('analysis-content').style.display = 'none';

    // å¦‚æœAIå…ˆæ‰‹
    if (data.ai_move) {
      lastAiMove = data.ai_move;
      addHistory(-humanSide, data.ai_move.label || 'AIèµ°æ£‹');
      if (data.ai_analysis) updateAnalysis(data.ai_analysis);
    }

    render();
    updateTurnInfo();
  } catch (e) {
    alert('å¼€å§‹æ¸¸æˆå¤±è´¥: ' + e.message);
  }
  hideLoading();
}

function showLoading(text) {
  document.getElementById('loading-text').textContent = text || 'åŠ è½½ä¸­...';
  document.getElementById('loading').classList.add('show');
}
function hideLoading() {
  document.getElementById('loading').classList.remove('show');
}

// ============================================================
// åˆå§‹åŒ–
// ============================================================
window.addEventListener('load', () => {
  render();
  loadModels();
});
</script>
</body>
</html>
